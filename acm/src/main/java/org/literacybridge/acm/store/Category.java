package org.literacybridge.acm.store;

import com.google.common.collect.Lists;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

public class Category implements Cloneable {
    public static class CategoryBuilder {
        private String id;
        private String name;
        private int order = 0;
        private boolean nonAssignable = false;
        private boolean visible = true;
        private boolean autogenerated = false;
        private Collection<String> aka = null;

        public CategoryBuilder(String id) {this.id = id;}

        public Category build() {
            if (this.id == null) throw new IllegalArgumentException("Category ID must be given");
            if (this.name == null) throw new IllegalArgumentException("Category Name must be given");
            if (this.aka != null) {
                this.aka = this.aka.stream().map(String::toLowerCase).collect(Collectors.toSet());
            }
            return new Category(this);
        }
        public CategoryBuilder withName(String name) {this.name = name; return this;}
        CategoryBuilder withOrder(int order) {this.order = order; return this;}
        CategoryBuilder nonAssignable(boolean nonAssignable) {this.nonAssignable = nonAssignable; return this;}
        public CategoryBuilder visible() {this.visible = true; return this;}
        CategoryBuilder withVisibility(boolean visibility) {this.visible = visibility; return this;}
        CategoryBuilder autogenerated() {this.autogenerated = true; return this;}
        CategoryBuilder autogenerated(boolean autogenerated) {this.autogenerated = autogenerated; return this;}
        CategoryBuilder alsoKnownAs(Collection<String> aliases) {this.aka = aliases; return this;}

    }
    
    
  private final String id;
  private final String name;
  private final Set<String> aka;
  private final int order;
  private Category parent;
  private final List<Category> children;
  // If this is true, it should not be possible to assign a message to the category. To effect that,
  // the 'categories' tree control omits them.
  // TODO: A better and more general solution will be to make the visible categories configurable by
  // project.
  private final boolean nonAssignable;
  // Should this category be shown to the user? If not, a message won't be able to be assigned
  // to the category.
  private boolean visible;
  // true if the category was added by software, not by the taxonomy. Currently, this means the
  // "buckets" in user feedback categories.
  private final boolean autogenerated;

    @SuppressWarnings({ "MethodDoesntCallSuperMethod", "RedundantThrows" })
    @Override
    public Category clone() throws CloneNotSupportedException {
        Category clone = new CategoryBuilder(this.id)
            .withName(this.name)
            .alsoKnownAs(this.aka)
            .withOrder(this.order)
            .nonAssignable(this.nonAssignable)
            .autogenerated(this.autogenerated)
            .withVisibility(this.visible)
            .build();

        for (Category child : this.children) {
            Category newChild = child.clone();
            newChild.parent = clone;
            clone.children.add(newChild);
        }
        return clone;
    }

  private Category(CategoryBuilder builder) {
      this.id = builder.id;
      this.name = builder.name;
      this.children = new ArrayList<>();
      this.nonAssignable = builder.nonAssignable;
      this.visible = builder.visible && !nonAssignable;
      this.aka = builder.aka==null ? null : new HashSet<>(builder.aka);
      this.order = builder.order;
      this.autogenerated = builder.autogenerated;
  }

  public boolean isKnownAs(String name) {
        return this.name.equalsIgnoreCase(name) ||
            this.aka != null && this.aka.contains(name.toLowerCase());
  }

  public String getCategoryName() {
    return name;
  }
  public String getFullName() {
      // If no parent, it's the root; we don't care that the root has a name of "root".
      if (parent == null) return "";
      // Name, if any, of the parent.
      String parentName = parent.getFullName();
      if (parentName.length() == 0) return name;
      // Append this node's name with the parent.
      return parentName + ":" + name;
  }

  public int getOrder() {
    return order;
  }

  public Category getParent() {
    return parent;
  }

  void addChild(Category childCategory) {
    if (childCategory.parent != null) throw new IllegalStateException("Category is already child of another category.");
    children.add(childCategory);
    childCategory.parent = this;
  }

  public Collection<Category> getChildren() {
    return children;
  }

  public Collection<Category> getSortedChildren() {
    List<Category> sorted = Lists.newArrayList(children);
    sorted.sort(Comparator.comparingInt(Category::getOrder));

    return sorted;
  }

  public boolean hasChildren() {
    return !children.isEmpty();
  }

  public String getId() {
      return id;
  }

  @Override
  public String toString() {
    return this.name;
  }

    public boolean isNonAssignable() {
        return nonAssignable;
    }

    public boolean isVisible() {
        return visible;
    }

    public void updateVisibility(boolean visible) {
        this.visible = visible;
    }

    public boolean hasVisibleChildren() {
        for (Category child : children) {
            if (child.isVisible() || child.hasVisibleChildren()) return true;
        }
        return false;
    }

    public boolean isChildOf(Category cat) {
        Category test = this;
        while (test != null) {
            if (cat.equals(test)) {
                return true;
            }
            test = test.getParent();
        }
        return false;

    }

    /**
     * Searches for a child with the given name. Performs a breadth first search, and returns the
     * first item found. If the name may be ambiguous within the tree, it is possible to perform
     * an step-by-step search through levels, by joining (with ':') names at successively deeper
     * levels. In this way, it is possible to specify a parent in which the child should be
     * unique.
     * @param targetFullName Name of the category, or a path of category names concatenated with
     *                       ':'.
     * @return The first matching Category found, or null if none is found.
     */
    public Category findChildWithName(String targetFullName) {
        String[] parts = targetFullName.split(":", 2);
        String name = parts[0].trim();
        Category matching = breadthFirstIterator().stream()
            .filter(cat -> cat.getCategoryName().equals(name))
            .findFirst()
            .orElse(null);
        if (matching != null) {
            if (parts.length > 1) {
                matching = matching.findChildWithName(parts[1].trim());
            }
        }
        return matching;
    }

    /**
     * Returns an iterator that will perform a depth first iteration of the children of this
     * Category.
     *
     * The iterator also contains a "stream()" convenience function, which simply calls
     * StreamSupport.stream(this.spliterator(), false). This makes it possible to simply call,
     * for instance,
     *   List<String> categoryNames = category.breadthFirstIterator()
     *       .stream()
     *       .map(Category::getCategoryName)
     *       .collect(Collectors.toList())
     *
     * @return the iterator.
     */
    public CategoryIterable breadthFirstIterator() {
        return new CategoryIterable(this);
    }
    public static class CategoryIterable implements Iterable<Category> {
        Category root;
        CategoryIterable(Category root) {
            this.root = root;
        }

        @Override
        public CategoryIterator iterator() {
            return new CategoryIterator(root);
        }

        public Stream<Category> stream() {
            return StreamSupport.stream(this.spliterator(), false);
        }

    }

    private static class CategoryIterator implements Iterator<Category> {
        private List<Category> queue = new ArrayList<>();
        private CategoryIterator(Category root) {
            queue.addAll(root.getSortedChildren());
        }
        @Override
        public boolean hasNext() {
            return !queue.isEmpty();
        }

        @Override
        public Category next() {
            Category next = queue.remove(0);
            queue.addAll(next.getSortedChildren());
            return next;
        }
    }



    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Category category = (Category) o;
        return Objects.equals(id, category.id) && Objects.equals(name, category.name)
            && Objects.equals(parent, category.parent) && Objects.equals(visible, category.visible);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name, parent, visible);
    }

//    public void setAutogenerated(boolean b) {
//      this.autogenerated = b;
//    }
    public boolean isAutogenerated() {
      return this.autogenerated;
    }
}
