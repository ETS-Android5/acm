package org.literacybridge.acm.store;

import com.google.common.collect.Lists;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

public class Category implements Cloneable {
    public static class CategoryBuilder {
        private String id;
        private String name;
        private int order = 0;
        private boolean nonAssignable = false;
        private boolean visible = true;
        private boolean autogenerated = true;
        private List<String> aliases = null;

        public CategoryBuilder(String id) {this.id = id;}

        public Category build() {
            if (this.id == null) throw new IllegalArgumentException("Category ID must be given");
            if (this.name == null) throw new IllegalArgumentException("Category Name must be given");
            Category cat = new Category(id);
            cat.name = this.name;
            cat.order = this.order;
            cat.nonAssignable = this.nonAssignable;
            cat.visible = this.visible;
            cat.autogenerated = this.autogenerated;
            if (aliases != null && aliases.size() > 0) {
                cat.aka = aliases.stream().map(String::toLowerCase).collect(Collectors.toSet());
            }
            return cat;
        }
        public CategoryBuilder withId(String id) {this.id = id; return this;}
        public CategoryBuilder withName(String name) {this.name = name; return this;}
        public CategoryBuilder withOrder(int order) {this.order = order; return this;}
        public CategoryBuilder nonAssignable() {this.nonAssignable = true; return this;}
        public CategoryBuilder nonAssignable(boolean nonAssignable) {this.nonAssignable = nonAssignable; return this;}
        public CategoryBuilder visible() {this.visible = true; return this;}
        public CategoryBuilder withVisibility(boolean visibility) {this.visible = visibility; return this;}
        public CategoryBuilder autogenerated() {this.autogenerated = true; return this;}
        public CategoryBuilder alsoKnownAs(List<String> aliases) {this.aliases = aliases; return this;}
    }
    
    
  private final String id;
  private String name;
  private Set<String> aka;
  private int order;
  private Category parent;
  private final List<Category> children;
  // If this is true, it should not be possible to assign a message to the category. To effect that,
  // the 'categories' tree control omits them.
  // TODO: A better and more general solution will be to make the visible categories configurable by
  // project.
  private boolean nonAssignable;
  // Should this category be shown to the user? If not, a message won't be able to be assigned
  // to the category.
  private boolean visible;
  // true if the category was added by software, not by the taxonomy. Currently, this means the
  // "buckets" in user feedback categories.
  private boolean autogenerated = false;

    @Override
    public Category clone() throws CloneNotSupportedException {
        super.clone();
        Category clone = new Category(this.id);
        clone.name = this.name;
        clone.aka = new HashSet<>(this.aka);
        clone.order = this.order;
        clone.nonAssignable = this.nonAssignable;
        // Non-assignable categories should not be visible.
        clone.visible = this.visible && !this.nonAssignable;
        clone.autogenerated = this.autogenerated;
        for (Category child : this.children) {
            Category newChild = child.clone();
            newChild.parent = clone;
            clone.children.add(newChild);
        }
        return clone;
    }

  private Category(String id) {
    this.id = id;
    this.children = Lists.newLinkedList();
    this.nonAssignable = false;
    this.visible = true;
  }

  public boolean isKnownAs(String name) {
        return this.name.equalsIgnoreCase(name) ||
            this.aka != null && this.aka.contains(name.toLowerCase());
  }

  public String getCategoryName() {
    return name;
  }
  public String getFullName() {
      // If no parent, it's the root; we don't care that the root has a name of "root".
      if (parent == null) return "";
      // Name, if any, of the parent.
      String parentName = parent.getFullName();
      if (parentName.length() == 0) return name;
      // Append this node's name with the parent.
      return parentName + ":" + name;
  }

  public int getOrder() {
    return order;
  }

  public Category getParent() {
    return parent;
  }

  void addChild(Category childCategory) {
    if (childCategory.parent != null) throw new IllegalStateException("Category is already child of another category.");
    children.add(childCategory);
    childCategory.parent = this;
  }

  public Collection<Category> getChildren() {
    return children;
  }

  public Collection<Category> getSortedChildren() {
    List<Category> sorted = Lists.newArrayList(children);
    sorted.sort((c1, c2) -> c1.getOrder() - c2.getOrder());

    return sorted;
  }

  public boolean hasChildren() {
    return !children.isEmpty();
  }

  public String getId() {
      return id;
  }

  @Override
  public String toString() {
    return this.name;
  }

    public boolean isNonAssignable() {
        return nonAssignable;
    }

    public boolean isVisible() {
        return visible;
    }

    public void updateVisibility(boolean visible) {
        this.visible = visible;
    }

    public boolean hasVisibleChildren() {
        for (Category child : children) {
            if (child.isVisible() || child.hasVisibleChildren()) return true;
        }
        return false;
    }

    public boolean isChildOf(Category cat) {
        Category test = this;
        while (test != null) {
            if (cat.equals(test)) {
                return true;
            }
            test = test.getParent();
        }
        return false;

    }

    /**
     * Searches for a child with the given name. Performs a breadth first search, and returns the
     * first item found. If the name may be ambiguous within the tree, it is possible to perform
     * an step-by-step search through levels, by joining (with ':') names at successively deeper
     * levels. In this way, it is possible to specify a parent in which the child should be
     * unique.
     * @param targetFullName Name of the category, or a path of category names concatenated with
     *                       ':'.
     * @return The first matching Category found, or null if none is found.
     */
    public Category findChildWithName(String targetFullName) {
        String[] parts = targetFullName.split(":", 2);
        String name = parts[0].trim();
        Category matching = breadthFirstIterator().stream()
            .filter(cat -> cat.getCategoryName().equals(name))
            .findFirst()
            .orElse(null);
        if (matching != null) {
            if (parts.length > 1) {
                matching = matching.findChildWithName(parts[1].trim());
            }
        }
        return matching;
    }

    /**
     * Returns an iterator that will perform a depth first iteration of the children of this
     * Category.
     *
     * The iterator also contains a "stream()" convenience function, which simply calls
     * StreamSupport.stream(this.spliterator(), false). This makes it possible to simply call,
     * for instance,
     *   List<String> categoryNames = category.breadthFirstIterator()
     *       .stream()
     *       .map(Category::getCategoryName)
     *       .collect(Collectors.toList())
     *
     * @return the iterator.
     */
    public CategoryIterable breadthFirstIterator() {
        return new CategoryIterable(this);
    }
    public static class CategoryIterable implements Iterable<Category> {
        Category root;
        CategoryIterable(Category root) {
            this.root = root;
        }

        @Override
        public CategoryIterator iterator() {
            return new CategoryIterator(root);
        }

        public Stream<Category> stream() {
            return StreamSupport.stream(this.spliterator(), false);
        }

    };
    private static class CategoryIterator implements Iterator<Category> {
        private List<Category> queue = new ArrayList<>();
        private CategoryIterator(Category root) {
            queue.addAll(root.getSortedChildren());
        }
        @Override
        public boolean hasNext() {
            return !queue.isEmpty();
        }

        @Override
        public Category next() {
            Category next = queue.remove(0);
            queue.addAll(next.getSortedChildren());
            return next;
        }
    }



    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Category category = (Category) o;
        return Objects.equals(id, category.id) && Objects.equals(name, category.name)
            && Objects.equals(parent, category.parent) && Objects.equals(visible, category.visible);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name, parent, visible);
    }

//    public void setAutogenerated(boolean b) {
//      this.autogenerated = b;
//    }
    public boolean isAutogenerated() {
      return this.autogenerated;
    }
}
